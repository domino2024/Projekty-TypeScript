// jeden-z-dziesieciu.ts
import * as readline from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

/** ========= Typy i narzÄ™dzia ========= */
type QA = {
    pytanie: string;
    odpowiedzi?: [string, string, string, string]; // jeÅ›li podane, poprawna to litera A-D
    poprawna: string; // litera (A-D) albo fraza przy pytaniu otwartym
};
type Player = {
    seat: number;
    name: string;
    lives: number;  // uÅ¼ywane w Etap 2 i 3 (3 Å¼ycia)
    score: number;  // punkty tylko w Etap 3
    alive: boolean;
    e3_correctA: number; // liczn. poprawnych w czÄ™Å›ci A finaÅ‚u
};

const LITERY = ["A", "B", "C", "D"] as const;
type Litera = typeof LITERY[number];

function shuffle<T>(arr: T[]): T[] {
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
}
function normalizeAnswer(s: string): string {
    return s.trim().toLowerCase().replace(/\s+/g, " ");
}
function wrap(text: string, width = 72): string {
    const words = text.split(/\s+/);
    const lines: string[] = [];
    let line = "";
    for (const w of words) {
        if ((line + " " + w).trim().length > width) {
            lines.push(line.trim());
            line = w;
        } else line += " " + w;
    }
    if (line.trim()) lines.push(line.trim());
    return lines.join("\n");
}
async function promptLine(rl: readline.Interface, q: string): Promise<string> {
    return (await rl.question(q)).trim();
}
function hr(title?: string) {
    console.log("\n" + "=".repeat(72));
    if (title) console.log(title);
    console.log("=".repeat(72) + "\n");
}
function showLives(p: Player) {
    return "â¤".repeat(p.lives) + "Â·".repeat(Math.max(0, 3 - p.lives));
}
function pause(ms = 250) { return new Promise(res => setTimeout(res, ms)); }

/** ========= Baza pytaÅ„ (przykÅ‚adowa) ========= */
const PYTANIA: QA[] = [
    // otwarte
    { pytanie: "Stolica Polski toâ€¦", poprawna: "warszawa" },
    { pytanie: "Ile jest kontynentÃ³w na Ziemi (liczbowo)?", poprawna: "7" },
    { pytanie: "NajdÅ‚uÅ¼sza rzeka w Polsce toâ€¦", poprawna: "wisÅ‚a" },
    { pytanie: "Chemiczny symbol sodu toâ€¦", poprawna: "na" },
    { pytanie: "W ktÃ³rym mieÅ›cie jest wieÅ¼a Eiffla?", poprawna: "paryÅ¼" },
    { pytanie: "Ile minut ma godzina?", poprawna: "60" },
    { pytanie: "Autor 'Pana Tadeusza' toâ€¦", poprawna: "adam mickiewicz" },
    { pytanie: "JÄ™zyk urzÄ™dowy w Brazylii toâ€¦", poprawna: "portugalski" },
    { pytanie: "NajbliÅ¼sza SÅ‚oÅ„cu planeta toâ€¦", poprawna: "merkury" },
    { pytanie: "StolicÄ… Kanady jestâ€¦", poprawna: "ottawa" },
    { pytanie: "Stolica WÅ‚och toâ€¦", poprawna: "rzym" },
    { pytanie: "Waluta Japonii toâ€¦", poprawna: "jen" },
    { pytanie: "KtÃ³re miasto leÅ¼y nad WeÅ‚tawÄ…? (po polsku)", poprawna: "praga" },
    { pytanie: "NajwiÄ™kszy kontynent toâ€¦", poprawna: "azja" },
    { pytanie: "Rzeka w ParyÅ¼u toâ€¦", poprawna: "sekwana" },
    { pytanie: "Na ktÃ³rym kontynencie leÅ¼y Egipt (gÅ‚Ã³wnie)?", poprawna: "afryka" },
    { pytanie: "Stolica Niemiec toâ€¦", poprawna: "berlin" },
    { pytanie: "PaÅ„stwo wyspiarskie ze stolicÄ… Tokio: â€¦", poprawna: "japonia" },
    { pytanie: "PaÅ„stwo z flagÄ… z liÅ›ciem klonu: â€¦", poprawna: "kanada" },
    { pytanie: "NajwiÄ™kszy ssak morski toâ€¦", poprawna: "pÅ‚etwal bÅ‚Ä™kitny" },

    // wariantowe
    {
        pytanie: "KtÃ³ry ocean jest najwiÄ™kszy?",
        odpowiedzi: ["Atlantycki", "Spokojny (Pacyfik)", "Indyjski", "Arktyczny"],
        poprawna: "B",
    },
    {
        pytanie: "KtÃ³ry pierwiastek ma symbol O?",
        odpowiedzi: ["ZÅ‚oto", "Cyna", "Tlen", "Srebro"],
        poprawna: "C",
    },
    {
        pytanie: "W ktÃ³rym roku upadÅ‚ Mur BerliÅ„ski?",
        odpowiedzi: ["1987", "1989", "1991", "1993"],
        poprawna: "B",
    },
    {
        pytanie: "KtÃ³ry gaz dominuje w atmosferze Ziemi?",
        odpowiedzi: ["Tlen", "Azot", "Dwutlenek wÄ™gla", "Argon"],
        poprawna: "B",
    },
    {
        pytanie: "Kto namalowaÅ‚ 'GwiaÅºdzistÄ… noc'?",
        odpowiedzi: ["Vincent van Gogh", "Claude Monet", "Pablo Picasso", "Paul CÃ©zanne"],
        poprawna: "A",
    },
    {
        pytanie: "KtÃ³ry jÄ™zyk ma najwiÄ™cej native speakerÃ³w?",
        odpowiedzi: ["HiszpaÅ„ski", "MandaryÅ„ski", "Angielski", "Hindustani"],
        poprawna: "B",
    },
    {
        pytanie: "Twierdzenie Pitagorasa dotyczy trÃ³jkÄ…tÃ³wâ€¦",
        odpowiedzi: ["RÃ³wnobocznych", "ProstokÄ…tnych", "RÃ³wnoramiennych", "Dowolnych"],
        poprawna: "B",
    },
];

class Deck {
    private pool: QA[];
    private used = 0;
    constructor(q: QA[]) { this.pool = shuffle([...q]); }
    draw(): QA {
        if (this.used >= this.pool.length) {
            this.used = 0;
            this.pool = shuffle(this.pool);
        }
        return this.pool[this.used++];
    }
}

function formatQA(q: QA): string {
    const lines = [wrap(q.pytanie)];
    if (q.odpowiedzi) {
        q.odpowiedzi.forEach((o, i) => lines.push(` ${LITERY[i]}) ${o}`));
    }
    return lines.join("\n");
}
async function askQA(
    rl: readline.Interface,
    q: QA,
    prefix = ""
): Promise<boolean> {
    console.log("\n" + "-".repeat(72));
    console.log(formatQA(q));
    const ans = await promptLine(rl, `${prefix}OdpowiedÅº${q.odpowiedzi ? " (A/B/C/D)" : ""}: `);
    if (q.odpowiedzi) {
        const lit = ans.toUpperCase();
        const ok = LITERY.includes(lit as Litera) && lit === q.poprawna.toUpperCase();
        console.log(ok ? "âœ… Poprawna!" : `âŒ BÅ‚Ä™dna. Poprawna: ${q.poprawna.toUpperCase()}.`);
        return ok;
    } else {
        const ok = normalizeAnswer(ans) === normalizeAnswer(q.poprawna);
        console.log(ok ? "âœ… Poprawna!" : `âŒ BÅ‚Ä™dna. Poprawna: ${q.poprawna}.`);
        return ok;
    }
}

/** ========= ETAP 1 =========
 * 10 graczy, po 2 pytania, przechodzÄ… ci z â‰¥1 poprawnÄ….
 */
async function etap1(
    rl: readline.Interface,
    deck: Deck,
    players: Player[]
): Promise<Player[]> {
    hr("ETAP 1 â€“ Kwalifikacje: kaÅ¼dy z 10 graczy dostaje 2 pytania. Do etapu 2 przechodzÄ… ci, ktÃ³rzy majÄ… â‰¥1 poprawnÄ… odpowiedÅº.");

    const passed: Player[] = [];
    for (const p of players) {
        console.log(`\nâ–¶ ${p.seat}. ${p.name}`);
        let correct = 0;
        for (let r = 1; r <= 2; r++) {
            const q = deck.draw();
            const ok = await askQA(rl, q, `(${p.name}) `);
            if (ok) correct++;
            await pause();
        }
        console.log(`Wynik ${p.name}: ${correct}/2 ${correct >= 1 ? "â€” przechodzi âœ…" : "â€” odpada âŒ"}`);
        if (correct >= 1) passed.push(p);
    }

    if (passed.length < 3) {
        console.log("\nâš ï¸ Mniej niÅ¼ 3 osoby przeszÅ‚y. UzupeÅ‚niamy do 3 przez dogrywkÄ™ (nagÅ‚a Å›mierÄ‡).");
        const outsiders = players.filter(x => !passed.includes(x));
        while (passed.length < 3) {
            for (const o of outsiders) {
                const q = deck.draw();
                console.log(`\nDogrywka â€” ${o.name}`);
                const ok = await askQA(rl, q, `(${o.name}) `);
                if (ok && !passed.includes(o)) {
                    passed.push(o);
                    console.log(`â¡ï¸ ${o.name} doÅ‚Ä…cza do etapu 2.`);
                    if (passed.length >= 3) break;
                }
            }
        }
    }

    // Przygotuj do Etapu 2: 3 Å¼ycia, punkty=0, alive=true
    for (const p of passed) {
        p.lives = 3;
        p.score = 0;
        p.alive = true;
        p.e3_correctA = 0;
    }

    console.log("\nâœ… Do ETAPU 2 przechodzÄ…:");
    passed.forEach(p => console.log(`  â€¢ [${p.seat}] ${p.name}`));
    return passed;
}

/** ========= ETAP 2 =========
 * Gracz z gÅ‚osem wybiera INNEGO gracza. Pierwszy wybÃ³r: 1â€“5 â†’ 6â€“10 (i odwrotnie).
 * Poprawna â†’ odpowiadajÄ…cy przejmuje gÅ‚os.
 * BÅ‚Ä™dna â†’ -1 Å¼ycie odpowiadajÄ…cemu, gÅ‚os zostaje u wybierajÄ…cego.
 * Gramy aÅ¼ zostanie 3 graczy.
 */
function inOppositeHalf(pSeat: number, targetSeat: number): boolean {
    const a = pSeat <= 5 ? "L" : "R";
    const b = targetSeat <= 5 ? "L" : "R";
    return a !== b;
}
async function etap2(
    rl: readline.Interface,
    deck: Deck,
    players: Player[]
): Promise<Player[]> {
    hr("ETAP 2 â€“ WybÃ³r przeciwnika: kaÅ¼dy ma 3 Å¼ycia. Zaczyna najniÅ¼szy numer z uczestnikÃ³w. Gramy aÅ¼ zostanie 3 graczy.");

    let alive = [...players];
    alive.sort((a, b) => a.seat - b.seat);
    let holder = alive[0]; // ma gÅ‚os
    let firstPickMustOppositeHalf = true;

    const bySeat = new Map(alive.map(p => [p.seat, p]));

    while (alive.length > 3) {
        console.log(
            `\nğŸ™ï¸ GÅ‚os ma [${holder.seat}] ${holder.name}. ` +
            `Å»ywi: ${alive.map(p => `[${p.seat}]${p.name}(${showLives(p)})`).join(", ")}`
        );
        const targetStr = await promptLine(rl,
            `WskaÅ¼ numer zawodnika do odpowiedzi (nie siebie): `
        );
        const targetSeat = parseInt(targetStr, 10);
        const target = bySeat.get(targetSeat);

        if (!target || !target.alive || target === holder) {
            console.log("â›” BÅ‚Ä™dny wybÃ³r. SprÃ³buj ponownie.");
            continue;
        }
        if (firstPickMustOppositeHalf && !inOppositeHalf(holder.seat, target.seat)) {
            console.log("â›” Pierwszy wybÃ³r w etapie 2 musi byÄ‡ z przeciwnej poÅ‚Ã³wki (1â€“5 â†” 6â€“10).");
            continue;
        }

        // Zadaj pytanie wskazanemu
        const q = deck.draw();
        console.log(`\nâ“ Pytanie dla [${target.seat}] ${target.name}`);
        const ok = await askQA(rl, q, `(${target.name}) `);

        if (ok) {
            console.log(`âœ… ${target.name} przejmuje gÅ‚os.`);
            holder = target;                 // przejmuje gÅ‚os
        } else {
            target.lives -= 1;
            console.log(`â¤ï¸â€ğŸ©¹ ${target.name} traci Å¼ycie â†’ ${showLives(target)}`);
            if (target.lives <= 0) {
                target.alive = false;
                alive = alive.filter(p => p.alive);
                console.log(`ğŸª© ${target.name} odpada z etapu 2!`);
                // gÅ‚os pozostaje u wybierajÄ…cego (holder bez zmian)
            }
        }

        if (firstPickMustOppositeHalf) firstPickMustOppositeHalf = false;
        await pause();
    }

    console.log("\nâœ… Do ETAPU 3 (FinaÅ‚) przechodzÄ…:");
    alive.forEach(p => console.log(`  â€¢ [${p.seat}] ${p.name}`));
    // reset Å¼ycia do 3, punkty=0, alive=true, e3_correctA=0
    for (const p of alive) {
        p.lives = 3;
        p.alive = true;
        p.score = 0;
        p.e3_correctA = 0;
    }
    return alive;
}

/** ========= ETAP 3 (FinaÅ‚) =========
 * CzÄ™Å›Ä‡ A: buzzer (kto pierwszy) â€“ poprawna +10, liczymy poprawne A do 3 dla kogokolwiek â†’ czÄ™Å›Ä‡ B.
 * CzÄ™Å›Ä‡ B: gracz przy gÅ‚osie wybiera siebie lub innego.
 *   â€¢ JeÅ›li wybierze SIEBIE i odpowie dobrze: +20 i zachowuje gÅ‚os.
 *   â€¢ JeÅ›li wybierze INNEGO:
 *       â€“ poprawna: +10 i ten â€innyâ€ przejmuje gÅ‚os,
 *       â€“ bÅ‚Ä™dna: -1 Å¼ycie odpowiadajÄ…cemu, gÅ‚os pozostaje u wybierajÄ…cego.
 * BÅ‚Ä™dna zawsze -1 Å¼ycie odpowiadajÄ…cemu (A i B).
 * Maks. 40 pytaÅ„, koniec teÅ¼ gdy zostanie 1 gracz.
 */
async function etap3_final(
    rl: readline.Interface,
    deck: Deck,
    players: Player[]
): Promise<Player> {
    hr("ETAP 3 â€“ FinaÅ‚: CzÄ™Å›Ä‡ A (buzzer) potem CzÄ™Å›Ä‡ B (wybÃ³r). Maksymalnie 40 pytaÅ„.");

    let alive = [...players];
    let asked = 0;
    let holder: Player | null = null; // pojawi siÄ™ po pierwszej poprawnej w CzÄ™Å›ci A
    let inPartB = false;

    const bySeat = new Map(alive.map(p => [p.seat, p]));

    const showState = () => {
        console.log(
            "Stan: " + alive
                .map(p => `[${p.seat}]${p.name} ${showLives(p)} ${p.score}pkt`)
                .join(" | ")
        );
    };

    while (alive.length > 1 && asked < 40) {
        showState();
        const q = deck.draw();
        asked++;

        if (!inPartB) {
            // CzÄ™Å›Ä‡ A â€“ BUZZER
            console.log(`\nğŸ”” [${asked}/40] BUZZER â€” kto pierwszy zgÅ‚asza siÄ™ do odpowiedzi?`);
            console.log(formatQA(q));
            const whoStr = await promptLine(rl, "Podaj numer gracza (siedzenie 1â€“10 wÅ›rÃ³d finalistÃ³w): ");
            const whoSeat = parseInt(whoStr, 10);
            const who = bySeat.get(whoSeat);
            if (!who || !who.alive) {
                console.log("â›” BÅ‚Ä™dny numer â€” pytanie przepada.");
                continue;
            }
            const ok = await askQA(rl, q, `(${who.name}) `);
            if (ok) {
                who.score += 10;
                who.e3_correctA += 1;
                holder = who; // od teraz ktoÅ› ma â€gÅ‚osâ€
                console.log(`â• +10 pkt dla ${who.name} (poprawnych w A: ${who.e3_correctA})`);
                if (who.e3_correctA >= 3) {
                    inPartB = true;
                    console.log("â¡ï¸ OsiÄ…gniÄ™to 3 poprawne w czÄ™Å›ci A â€” przechodzimy do CzÄ™Å›ci B (wybÃ³r).");
                }
            } else {
                who.lives -= 1;
                console.log(`â¤ï¸â€ğŸ©¹ ${who.name} traci Å¼ycie â†’ ${showLives(who)}`);
                if (who.lives <= 0) {
                    who.alive = false;
                    alive = alive.filter(p => p.alive);
                    if (alive.length === 1) break;
                }
            }
        } else {
            // CzÄ™Å›Ä‡ B â€“ WYBÃ“R
            if (!holder || !holder.alive) {
                // jeÅ›li z jakiegoÅ› powodu brak â€gÅ‚osuâ€, przyznaj go najniÅ¼szemu seat Å¼ywemu
                holder = alive.slice().sort((a, b) => a.seat - b.seat)[0];
            }
            console.log(`\nğŸ™ï¸ [${asked}/40] CzÄ™Å›Ä‡ B â€” gÅ‚os ma [${holder.seat}] ${holder.name}`);
            console.log(formatQA(q));
            const targetStr = await promptLine(rl, "WskaÅ¼ numer zawodnika do odpowiedzi (moÅ¼na siebie): ");
            const targetSeat = parseInt(targetStr, 10);
            const target = bySeat.get(targetSeat);
            if (!target || !target.alive) {
                console.log("â›” BÅ‚Ä™dny wybÃ³r â€” pytanie przepada.");
                continue;
            }

            const ok = await askQA(rl, q, `(${target.name}) `);
            if (target === holder) {
                // wybraÅ‚ siebie
                if (ok) {
                    holder.score += 20;
                    console.log(`â• +20 pkt dla ${holder.name}. GÅ‚os pozostaje.`);
                } else {
                    holder.lives -= 1;
                    console.log(`â¤ï¸â€ğŸ©¹ ${holder.name} traci Å¼ycie â†’ ${showLives(holder)}`);
                    if (holder.lives <= 0) {
                        holder.alive = false;
                        alive = alive.filter(p => p.alive);
                        if (alive.length === 1) break;
                        // gÅ‚os przechodzi na najniÅ¼szy seat Å¼ywy
                        holder = alive.slice().sort((a, b) => a.seat - b.seat)[0];
                    }
                }
            } else {
                // wybraÅ‚ innego
                if (ok) {
                    target.score += 10;
                    console.log(`â• +10 pkt dla ${target.name}. Przejmuje gÅ‚os.`);
                    holder = target; // przejmuje gÅ‚os
                } else {
                    target.lives -= 1;
                    console.log(`â¤ï¸â€ğŸ©¹ ${target.name} traci Å¼ycie â†’ ${showLives(target)}`);
                    if (target.lives <= 0) {
                        target.alive = false;
                        alive = alive.filter(p => p.alive);
                        if (alive.length === 1) break;
                        // gÅ‚os zostaje u dotychczasowego holdera
                    }
                }
            }
        }
        await pause();
    }

    showState();

    // RozstrzygniÄ™cie: 1 Å¼ywy albo po 40 pytaniach â€” najwyÅ¼szy wynik
    let champion: Player;
    if (alive.length === 1) {
        champion = alive[0];
        console.log(`\nğŸ ZwyciÄ™zca przez eliminacjÄ™: ${champion.name} (${champion.score} pkt)`);
    } else {
        const top = players.slice().sort((a, b) => b.score - a.score);
        const bestScore = top[0].score;
        const tied = top.filter(p => p.score === bestScore && p.alive);
        if (tied.length === 1) {
            champion = tied[0];
            console.log(`\nğŸ ZwyciÄ™zca punktowy: ${champion.name} (${champion.score} pkt)`);
        } else {
            // Dogrywka na buzzer do pierwszej przewagi
            console.log("\nâš”ï¸ Dogrywka na buzzer pomiÄ™dzy:");
            tied.forEach(p => console.log(`  â€¢ ${p.name}`));
            while (true) {
                const q = deck.draw();
                console.log("\nDOGRYWKA â€” BUZZER");
                console.log(formatQA(q));
                const whoStr = await promptLine(rl, "Kto zgÅ‚asza siÄ™ pierwszy? Podaj numer siedzenia: ");
                const whoSeat = parseInt(whoStr, 10);
                const who = tied.find(p => p.seat === whoSeat && p.alive);
                if (!who) { console.log("â›” BÅ‚Ä™dny numer."); continue; }
                const ok = await askQA(rl, q, `(${who.name}) `);
                if (ok) { champion = who; break; }
            }
            console.log(`\nğŸ ZwyciÄ™zca po dogrywce: ${champion!.name} (${champion!.score} pkt)`);
        }
    }
    return champion!;
}

/** ========= MAIN ========= */
async function main() {
    const rl = readline.createInterface({ input, output });
    try {
        console.log("\nWitaj w grze: JEDEN Z DZIESIÄ˜CIU (konsola, TypeScript)\n");

        const players: Player[] = [];
        for (let i = 1; i <= 10; i++) {
            const name = (await promptLine(rl, `Podaj imiÄ™ gracza ${i} (Enter = Gracz${i}): `)) || `Gracz${i}`;
            players.push({ seat: i, name, lives: 0, score: 0, alive: true, e3_correctA: 0 });
        }

        const deck = new Deck(PYTANIA);

        // ETAP 1
        const p2 = await etap1(rl, deck, players);

        // ETAP 2
        const p3 = await etap2(rl, deck, p2);

        // ETAP 3 (FinaÅ‚)
        const champion = await etap3_final(rl, deck, p3);

        console.log("\n" + "=".repeat(72));
        console.log(`ğŸ‰ MISTRZ ODCINKA: ${champion.name}! Wynik: ${champion.score} pkt`);
        console.log("=" .repeat(72) + "\n");
    } finally {
        // @ts-ignore
        rl.close();
    }
}

main().catch(e => {
    console.error("BÅ‚Ä…d:", e);
});

